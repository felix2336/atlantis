"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemberManager = exports.ExtendedClient = exports.Modal = exports.MentionableSelectMenu = exports.UserSelectMenu = exports.ChannelSelectMenu = exports.RoleSelectMenu = exports.StringSelectMenu = exports.Button = exports.MessageContextMenu = exports.UserContextMenu = exports.SlashCommand = exports.Event = exports.Poll = void 0;
const discord_js_1 = require("discord.js");
const fs_1 = require("fs");
const chalk_1 = require("chalk");
class Cooldown {
    constructor() {
        this.cooldowns = {};
    }
    /**
     * Setzt einen Cooldown für einen bestimmten User und Befehl
     * @param userId Die ID des Users
     * @param command Der Name des Befehls
     * @param duration Der Cooldown in Minuten
     */
    set(userId, command, duration) {
        const now = Date.now();
        const cooldownAmount = duration * 60 * 1000;
        const expirationTime = now + cooldownAmount;
        if (!this.cooldowns[command]) {
            this.cooldowns[command] = {};
        }
        this.cooldowns[command][userId] = expirationTime;
        setTimeout(() => delete this.cooldowns[command][userId], cooldownAmount);
    }
    /**
     * Prüft, ob ein User für einen Befehl im Cooldown ist
     * @param userId Die ID des Users
     * @param command Der Name des Befehls
     * @returns `true` wenn sich der User im Cooldown befindet. Andernfalls `false`
     */
    isInCooldown(userId, command) {
        if (!this.cooldowns[command])
            return false;
        if (!this.cooldowns[command][userId])
            return false;
        const expirationTime = this.cooldowns[command][userId];
        const now = Date.now();
        if (now >= expirationTime) {
            delete this.cooldowns[command][userId];
            return false;
        }
        return true;
    }
    /**
     * Gibt die verbleibende Cooldown Zeit in Minuten zurück
     * @param userId Die ID des Users
     * @param command Der Name des Befehls
     */
    getRemainingTime(userId, command) {
        if (!this.cooldowns[command])
            return '0';
        if (!this.cooldowns[command][userId])
            return '0';
        const expirationTime = this.cooldowns[command][userId];
        const now = Date.now();
        return ((expirationTime - now) / 60000).toFixed(2);
    }
}
class Poll {
    constructor(data) {
        this.question = data.question;
        this.answers = data.answers;
        this.duration = data.duration;
        this.allowMultiselect = data.allowMultiselect;
        this.layoutType = data.layoutType;
    }
}
exports.Poll = Poll;
class Event {
    constructor(data) {
        this.name = data.name;
        this.once = data.once;
        this.execute = data.execute;
    }
}
exports.Event = Event;
class SlashCommand {
    constructor(data) {
        this.data = data.data;
        this.cooldown = data.cooldown;
        this.execute = data.execute;
    }
}
exports.SlashCommand = SlashCommand;
class UserContextMenu {
    constructor(data) {
        data.data.setType(2);
        this.data = data.data;
        this.execute = data.execute;
    }
}
exports.UserContextMenu = UserContextMenu;
class MessageContextMenu {
    constructor(data) {
        data.data.setType(3);
        this.data = data.data;
        this.execute = data.execute;
    }
}
exports.MessageContextMenu = MessageContextMenu;
class Button {
    constructor(data) {
        this.id = data.id;
        this.execute = data.execute;
    }
}
exports.Button = Button;
class StringSelectMenu {
    constructor(data) {
        this.id = data.id;
        this.execute = data.execute;
    }
}
exports.StringSelectMenu = StringSelectMenu;
class RoleSelectMenu {
    constructor(data) {
        this.id = data.id;
        this.execute = data.execute;
    }
}
exports.RoleSelectMenu = RoleSelectMenu;
class ChannelSelectMenu {
    constructor(data) {
        this.id = data.id;
        this.execute = data.execute;
    }
}
exports.ChannelSelectMenu = ChannelSelectMenu;
class UserSelectMenu {
    constructor(data) {
        this.id = data.id;
        this.execute = data.execute;
    }
}
exports.UserSelectMenu = UserSelectMenu;
class MentionableSelectMenu {
    constructor(data) {
        this.id = data.id;
        this.execute = data.execute;
    }
}
exports.MentionableSelectMenu = MentionableSelectMenu;
class Modal {
    constructor(data) {
        this.id = data.id;
        this.execute = data.execute;
    }
}
exports.Modal = Modal;
class ExtendedClient extends discord_js_1.Client {
    constructor(options) {
        super(options);
        this.apps = [];
        this.commands = new discord_js_1.Collection;
        this.userContextMenus = new discord_js_1.Collection;
        this.messageContextMenus = new discord_js_1.Collection;
        this.modals = new discord_js_1.Collection;
        this.stringSelectMenus = new discord_js_1.Collection;
        this.roleSelectMenus = new discord_js_1.Collection;
        this.channelSelectMenus = new discord_js_1.Collection;
        this.userSelectMenus = new discord_js_1.Collection;
        this.mentionableSelectMenus = new discord_js_1.Collection;
        this.buttons = new discord_js_1.Collection;
        this.cooldowns = new Cooldown;
    }
    /**
     * Sendet jegliche DM Nachrichten, die an den Bot geschickt werden in einen spezifischen Channel
     * @param channelId Die ID des Textkanals , in den DM Nachrichten an den Bot gesendet werden sollen
     */
    enableDmLog(channelId) {
        this.once('ready', () => {
            var _a;
            if (!this.options.intents.has('DirectMessages') || !((_a = this.options.partials) === null || _a === void 0 ? void 0 : _a.includes(discord_js_1.Partials.Channel)) || !this.options.intents.has('MessageContent') || !this.channels.cache.get(channelId)) {
                this.error('DM Logger konnte nicht aktiviert werden, da mindestens eine der Folgenden Abhängigkeiten nicht gegeben ist:');
                this.error('Ungültige Kanal ID');
                this.error('Intent: "DirectMessages"');
                this.error('Intent: "MessageContent"');
                this.error('Partial: "Channel"');
                this.error('Stelle sicher, dass all diese Abhängigkeiten gegeben sind und versuche es erneut');
            }
            else {
                this.info('DM Logger aktiviert!');
                this.on('messageCreate', (message) => __awaiter(this, void 0, void 0, function* () {
                    if (message.channel.type != discord_js_1.ChannelType.DM)
                        return;
                    const channel = this.channels.cache.get(channelId);
                    const embed = new discord_js_1.EmbedBuilder({
                        author: { name: message.author.username, iconURL: message.author.displayAvatarURL() },
                        description: message.content,
                        color: discord_js_1.Colors.Gold
                    });
                    yield channel.send({ embeds: [embed] });
                }));
            }
        });
    }
    /**
     * Aktiviert die automatische Rollenverteilung für neue Mitglieder
     * @param roles Die ID oder IDs der Rolle/n
     */
    enableAutoRole(...roles) {
        if (!this.options.intents.has('GuildMembers')) {
            this.error('AutoRole konnte nicht aktiviert werden, da der Intent "GuildMembers" nicht gegeben ist!');
            return;
        }
        else {
            this.info('AutoRole aktiviert!');
            this.once('ready', () => __awaiter(this, void 0, void 0, function* () {
                this.on('guildMemberAdd', (member) => __awaiter(this, void 0, void 0, function* () {
                    member.roles.add(roles);
                }));
            }));
        }
    }
    /**
     * Gibt eine Nachricht im Format `[{ZEIT} WARN] {message}` aus
     * @param message Die Warnung
     */
    warn(message) {
        console.log(chalk_1.default.yellowBright(`[${new Date().toLocaleTimeString('de-DE')} WARN] ${message}`));
    }
    /**
     * Gibt eine Nachricht im Format `[{ZEIT} INFO] {message}` aus
     * @param message Die Info Nachricht
     */
    info(message) {
        console.log(chalk_1.default.greenBright(`[${new Date().toLocaleTimeString('de-DE')} INFO]`), chalk_1.default.whiteBright(message));
    }
    /**
     * Gibt eine Rote nachricht im Format `[{ZEIT} ERROR] {message}` aus
     * @param message Die Error Nachricht
     * */
    error(message) {
        console.log(chalk_1.default.redBright(`[${new Date().toLocaleTimeString('de-DE')} ERROR] ${message}`));
    }
    /**Gibt eine Meldung in der Konsole, wenn der Bot bereit ist */
    logWhenReady() {
        this.on('ready', () => {
            this.info(`Logged in as ${this.user.tag}`);
        });
    }
    /**
     * Kümmert sich um alle Interactions
     * @param client Nur erforderlich, wenn eine eigene Client-Klasse verwendet wird
     * */
    handleInteractions(client) {
        this.on('interactionCreate', (interaction) => __awaiter(this, void 0, void 0, function* () {
            switch (true) {
                case interaction.isChatInputCommand(): {
                    const command = this.commands.get(interaction.commandName);
                    if (!command) {
                        interaction.reply({ content: 'This command could not be found!', ephemeral: true });
                        break;
                    }
                    if (command.cooldown) {
                        if (this.cooldowns.isInCooldown(interaction.user.id, command.data.name)) {
                            const remainingTime = this.cooldowns.getRemainingTime(interaction.user.id, interaction.commandName);
                            const embed = new discord_js_1.EmbedBuilder({
                                title: 'Cooldown',
                                description: `Du musst noch ${remainingTime} Minuten warten, bis du diesen Befehl erneut verwenden kannst!`,
                                color: discord_js_1.Colors.Gold
                            });
                            interaction.reply({ embeds: [embed], ephemeral: true });
                            return;
                        }
                        else {
                            this.cooldowns.set(interaction.user.id, interaction.commandName, command.cooldown);
                        }
                    }
                    command.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isButton(): {
                    const button = this.buttons.get(interaction.customId);
                    if (!button) {
                        interaction.reply({ content: 'This button could not be found!', ephemeral: true });
                        break;
                    }
                    button.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isStringSelectMenu(): {
                    const stringSelectMenu = this.stringSelectMenus.get(interaction.customId);
                    if (!stringSelectMenu) {
                        interaction.reply({ content: 'This StringSelectmenu could not be found!', ephemeral: true });
                        break;
                    }
                    stringSelectMenu.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isRoleSelectMenu(): {
                    const roleSelectMenu = this.roleSelectMenus.get(interaction.customId);
                    if (!roleSelectMenu) {
                        interaction.reply({ content: 'This RoleSelectMenu could not be found!', ephemeral: true });
                        break;
                    }
                    roleSelectMenu.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isChannelSelectMenu(): {
                    const channelSelectMenu = this.channelSelectMenus.get(interaction.customId);
                    if (!channelSelectMenu) {
                        interaction.reply({ content: 'This ChannelSelectMenu could not be found!', ephemeral: true });
                        break;
                    }
                    channelSelectMenu.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isUserSelectMenu(): {
                    const userSelectMenu = this.userSelectMenus.get(interaction.customId);
                    if (!userSelectMenu) {
                        interaction.reply({ content: 'This UserSelectMenu could not be found!', ephemeral: true });
                        break;
                    }
                    userSelectMenu.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isMentionableSelectMenu(): {
                    const mentionableSelectMenu = this.mentionableSelectMenus.get(interaction.customId);
                    if (!mentionableSelectMenu) {
                        interaction.reply({ content: 'This MenitonableSelectMenu could not be found!', ephemeral: true });
                        break;
                    }
                    mentionableSelectMenu.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isModalSubmit(): {
                    const modal = this.modals.get(interaction.customId);
                    if (!modal) {
                        interaction.reply({ content: 'This Modal could not be found!', ephemeral: true });
                        break;
                    }
                    modal.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isUserContextMenuCommand(): {
                    const userContextMenu = this.userContextMenus.get(interaction.commandName);
                    if (!userContextMenu) {
                        interaction.reply({ content: 'This UserContextMenu could not be found', ephemeral: true });
                        break;
                    }
                    userContextMenu.execute(interaction, client ? client : this);
                    break;
                }
                case interaction.isMessageContextMenuCommand(): {
                    const messageContextMenu = this.messageContextMenus.get(interaction.commandName);
                    if (!messageContextMenu) {
                        interaction.reply({ content: 'This MessageContextMenu could not be found!', ephemeral: true });
                        break;
                    }
                    messageContextMenu.execute(interaction, client ? client : this);
                    break;
                }
            }
        }));
    }
    deployCommands(guildIdOrIds) {
        this.on('ready', () => {
            if (Array.isArray(guildIdOrIds)) {
                for (const id of guildIdOrIds) {
                    const guild = this.guilds.cache.get(id);
                    if (!guild) {
                        this.error(`${id}: Could not load Commands because of invalid GuildId`);
                        continue;
                    }
                    guild.commands.set(this.apps.map(a => a.data));
                    this.info(`Deployed Commands to ${id}`);
                }
            }
            else {
                const guild = this.guilds.cache.get(guildIdOrIds);
                if (!guild) {
                    this.error(`${guildIdOrIds}: Could not deploy Commands because of invalid GuildId`);
                    return;
                }
                guild.commands.set(this.apps.map(a => a.data));
                this.info(`Deployed Commands to ${guild.name}`);
            }
        });
    }
    loadCommands(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`Commands path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn('Skip Load Commands because of no Commands');
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const command = module.default;
                if (!command || !command.data || !command.data.name || !command.data.description) {
                    this.warn(`Invalid Command in ${path}/${file}`);
                    continue;
                }
                this.commands.set(command.data.name, command);
                this.apps.push(command);
                this.info(`Slash Command ${command.data.name} loaded`);
            }
        });
    }
    loadEvents(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`Event path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn('Skip Load Events because of no Events');
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const event = module.default;
                if (!event || !event.name) {
                    this.warn(`Invalid Event in ${path}/${file}`);
                    continue;
                }
                if (event.once) {
                    this.once(event.name, (...args) => event.execute(this, ...args));
                }
                else {
                    this.on(event.name, (...args) => event.execute(this, ...args));
                }
                this.info(`"${event.name}" Event ${file.split('.')[0]} loaded`);
            }
        });
    }
    loadRoleSelectMenus(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`RoleSelectMenus path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn(`Skip loading RoleSelectMenus because of no RoleSelectMenus`);
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const menu = module.default;
                if (!menu || !menu.id) {
                    this.warn(`Invalid RoleSelectMenu in ${path}/${file}`);
                    return;
                }
                this.roleSelectMenus.set(menu.id, menu);
                this.info(`RoleSelectMenu ${menu.id} loaded`);
            }
        });
    }
    loadStringSelectMenus(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`StringSelectMenus path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn('Skip Load StringSelectMenus because of no StringSelectMenus');
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const menu = module.default;
                if (!menu || !menu.id) {
                    this.warn(`Invalid StringSelectMenu in ${path}/${file}`);
                    continue;
                }
                this.stringSelectMenus.set(menu.id, menu);
                this.info(`StringSelectMenu ${menu.id} loaded`);
            }
        });
    }
    loadChannelSelectMenus(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`ChannelSelectMenus path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn(`Skip load ChannelSelectMenus because of no ChannelSelectMenus`);
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const menu = module.default;
                if (!menu || !menu.id) {
                    this.warn(`Invalid ChannelSelectMenu in ${path}/${file}`);
                    return;
                }
                this.channelSelectMenus.set(menu.id, menu);
                this.info(`ChannelSelectMenu ${menu.id} loaded`);
            }
        });
    }
    loadUserSelectMenus(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`userSelectMenus path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn('Skip load UserSelectMenus because of no UserSelectMenus');
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const menu = module.default;
                if (!menu || !menu.id) {
                    this.warn(`Invalid UserSelectMenu in ${path}/${file}`);
                    return;
                }
                this.userSelectMenus.set(menu.id, menu);
                this.info(`UserSelectMenu ${menu.id} loaded`);
            }
        });
    }
    loadMentionableSelectMenus(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`MentionableSelectMenus path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn('Skip load MentionableSelectMenus because of no MentionableSelectMenus');
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const menu = module.default;
                if (!menu || !menu.id) {
                    this.warn(`Invalid MentionableSelectMenu in ${path}/${file}`);
                    return;
                }
                this.mentionableSelectMenus.set(menu.id, menu);
                this.info(`MentionableSelectMenu ${menu.id} loaded`);
            }
        });
    }
    loadButtons(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`Buttons path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn('Skip Load Buttons because of no Buttons');
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const button = module.default;
                if (!button || !button.id) {
                    this.warn(`Invalid Button in ${path}/${file}`);
                    continue;
                }
                this.buttons.set(button.id, button);
                this.info(`Button ${button.id} loaded`);
            }
        });
    }
    loadModals(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`Modals path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn('Skip Load Modals because of no Modals');
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const modal = module.default;
                if (!modal || !modal.id) {
                    this.warn(`Invalid Modal in ${path}/${file}`);
                    continue;
                }
                this.modals.set(modal.id, modal);
                this.info(`Modal ${modal.id} loaded`);
            }
        });
    }
    loadUserContextMenus(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`userContextMenus path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn(`Skip load UserContextMenus because of no UserContextMenus`);
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const menu = module.default;
                if (!menu.data.name) {
                    this.warn(`Invalid UserContextMenu in ${path}/${file}`);
                    return;
                }
                this.userContextMenus.set(menu.data.name, menu);
                this.apps.push(menu);
                this.info(`UserContextMenu ${menu.data.name} loaded`);
            }
        });
    }
    loadMessageContextMenus(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, fs_1.existsSync)(path)) {
                this.error(`MessageContextMenus path does not exist: ${path}`);
                return;
            }
            const files = (0, fs_1.readdirSync)(path).filter(f => f.endsWith('.ts'));
            if (!files || files.length == 0) {
                this.warn(`Skip load MessageContextMenus because of no MessageContextMenus`);
                return;
            }
            for (const file of files) {
                const module = yield Promise.resolve(`${`../../../${path}/${file}`}`).then(s => require(s));
                const menu = module.default;
                if (!menu.data.name) {
                    this.warn(`Invalid MessageContextMenu in ${path}/${file}`);
                    return;
                }
                this.messageContextMenus.set(menu.data.name, menu);
                this.apps.push(menu);
                this.info(`MessageContextMenu ${menu.data.name} loaded`);
            }
        });
    }
}
exports.ExtendedClient = ExtendedClient;
class MemberManager {
    constructor(member, guild) {
        this.member = member;
        this.guild = guild;
    }
    sendDM(options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.member.user.send(options)
                .catch(e => {
                return false;
            });
            return true;
        });
    }
}
exports.MemberManager = MemberManager;
