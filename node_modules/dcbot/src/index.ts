import { ChannelType, Client, ClientOptions, Collection, Colors, EmbedBuilder, Guild, GuildMember, GuildTextBasedChannel, MessageCreateOptions, MessagePayload, Partials, PermissionFlagsBits, PollAnswerData, PollData, PollLayoutType, PollQuestionMedia, RoleResolvable, SlashCommandBuilder } from 'discord.js'
import { readdirSync, existsSync } from 'fs'
import chalk from 'chalk'
import { ISlashCommand, IStringSelectMenu, IButton, IModal, IUserContextMenu, IMessageContextMenu, IRoleSelectMenu, IChannelSelectMenu, IUserSelectMenu, IMentionableSelectMenu, IEvent } from './types';

class Cooldown {
    private cooldowns: Record<string, Record<string, number>>

    constructor() {
        this.cooldowns = {}
    }

    /**
     * Setzt einen Cooldown für einen bestimmten User und Befehl
     * @param userId Die ID des Users
     * @param command Der Name des Befehls
     * @param duration Der Cooldown in Minuten
     */
    public set(userId: string, command: string, duration: number): void {
        const now = Date.now()
        const cooldownAmount = duration * 60 * 1000
        const expirationTime = now + cooldownAmount

        if (!this.cooldowns[command]) {
            this.cooldowns[command] = {}
        }

        this.cooldowns[command][userId] = expirationTime

        setTimeout(() => delete this.cooldowns[command][userId], cooldownAmount)
    }
    /**
     * Prüft, ob ein User für einen Befehl im Cooldown ist
     * @param userId Die ID des Users
     * @param command Der Name des Befehls
     * @returns `true` wenn sich der User im Cooldown befindet. Andernfalls `false`
     */
    public isInCooldown(userId: string, command: string): boolean {
        if (!this.cooldowns[command]) return false
        if (!this.cooldowns[command][userId]) return false

        const expirationTime = this.cooldowns[command][userId]
        const now = Date.now()

        if (now >= expirationTime) {
            delete this.cooldowns[command][userId]
            return false
        }

        return true
    }
    /**
     * Gibt die verbleibende Cooldown Zeit in Minuten zurück
     * @param userId Die ID des Users
     * @param command Der Name des Befehls
     */
    getRemainingTime(userId: string, command: string): string {
        if (!this.cooldowns[command]) return '0'
        if (!this.cooldowns[command][userId]) return '0'
        const expirationTime = this.cooldowns[command][userId]
        const now = Date.now()
        return ((expirationTime - now) / 60000).toFixed(2)
    }
}

export class Poll implements PollData {
    question: PollQuestionMedia;
    answers: readonly PollAnswerData[];
    duration: number;
    allowMultiselect: boolean;
    layoutType?: PollLayoutType | undefined;


    constructor(data: PollData) {
        this.question = data.question
        this.answers = data.answers
        this.duration = data.duration
        this.allowMultiselect = data.allowMultiselect
        this.layoutType = data.layoutType
    }
}

export class Event<ClientType extends ExtendedClient = ExtendedClient> {
    name: IEvent["name"]
    once: IEvent["once"]
    execute: IEvent<ClientType>["execute"]

    constructor(data: IEvent<ClientType>) {
        this.name = data.name
        this.once = data.once
        this.execute = data.execute
    }
}

export class SlashCommand<ClientType extends ExtendedClient = ExtendedClient> {
    data: ISlashCommand["data"]
    cooldown: ISlashCommand["cooldown"]
    execute: ISlashCommand<ClientType>["execute"]

    constructor(data: ISlashCommand<ClientType>) {
        this.data = data.data
        this.cooldown = data.cooldown
        this.execute = data.execute
    }
}

export class UserContextMenu<ClientType extends ExtendedClient = ExtendedClient> {
    data: IUserContextMenu["data"]
    execute: IUserContextMenu<ClientType>["execute"]

    constructor(data: IUserContextMenu<ClientType>) {
        data.data.setType(2)
        this.data = data.data
        this.execute = data.execute
    }
}

export class MessageContextMenu<ClientType extends ExtendedClient = ExtendedClient> {
    data: IMessageContextMenu["data"]
    execute: IMessageContextMenu<ClientType>["execute"]

    constructor(data: IMessageContextMenu<ClientType>) {
        data.data.setType(3)
        this.data = data.data
        this.execute = data.execute
    }
}

export class Button<ClientType extends ExtendedClient = ExtendedClient> {
    id: IButton["id"]
    execute: IButton<ClientType>["execute"]

    constructor(data: IButton<ClientType>) {
        this.id = data.id
        this.execute = data.execute
    }
}

export class StringSelectMenu<ClientType extends ExtendedClient = ExtendedClient> {
    id: IStringSelectMenu["id"]
    execute: IStringSelectMenu<ClientType>["execute"]

    constructor(data: IStringSelectMenu<ClientType>) {
        this.id = data.id
        this.execute = data.execute
    }
}

export class RoleSelectMenu<ClientType extends ExtendedClient = ExtendedClient> {
    id: IRoleSelectMenu["id"]
    execute: IRoleSelectMenu<ClientType>["execute"]

    constructor(data: IRoleSelectMenu<ClientType>) {
        this.id = data.id
        this.execute = data.execute
    }
}

export class ChannelSelectMenu<ClientType extends ExtendedClient = ExtendedClient> {
    id: IChannelSelectMenu["id"]
    execute: IChannelSelectMenu<ClientType>["execute"]

    constructor(data: IChannelSelectMenu<ClientType>) {
        this.id = data.id
        this.execute = data.execute
    }
}

export class UserSelectMenu<ClientType extends ExtendedClient = ExtendedClient> {
    id: IUserSelectMenu["id"]
    execute: IUserSelectMenu<ClientType>["execute"]

    constructor(data: IUserSelectMenu<ClientType>) {
        this.id = data.id
        this.execute = data.execute
    }
}

export class MentionableSelectMenu<ClientType extends ExtendedClient = ExtendedClient> {
    id: IMentionableSelectMenu["id"]
    execute: IMentionableSelectMenu<ClientType>["execute"]

    constructor(data: IMentionableSelectMenu<ClientType>) {
        this.id = data.id
        this.execute = data.execute
    }
}

export class Modal<ClientType extends ExtendedClient = ExtendedClient> {
    id: IModal["id"]
    execute: IModal<ClientType>["execute"]

    constructor(data: IModal<ClientType>) {
        this.id = data.id
        this.execute = data.execute
    }
}

export class ExtendedClient extends Client {
    public apps: SlashCommand[] & MessageContextMenu[] & UserContextMenu[];
    public commands: Collection<string, SlashCommand>;
    public userContextMenus: Collection<string, UserContextMenu>
    public messageContextMenus: Collection<string, MessageContextMenu>
    public modals: Collection<string, Modal>;
    public stringSelectMenus: Collection<string, StringSelectMenu>
    public roleSelectMenus: Collection<string, RoleSelectMenu>
    public channelSelectMenus: Collection<string, ChannelSelectMenu>
    public userSelectMenus: Collection<string, UserSelectMenu>
    public mentionableSelectMenus: Collection<string, MentionableSelectMenu>
    public buttons: Collection<string, Button>
    private cooldowns: Cooldown

    constructor(options: ClientOptions) {
        super(options)
        this.apps = []
        this.commands = new Collection
        this.userContextMenus = new Collection
        this.messageContextMenus = new Collection
        this.modals = new Collection
        this.stringSelectMenus = new Collection
        this.roleSelectMenus = new Collection
        this.channelSelectMenus = new Collection
        this.userSelectMenus = new Collection
        this.mentionableSelectMenus = new Collection
        this.buttons = new Collection
        this.cooldowns = new Cooldown
    }
    /**
     * Sendet jegliche DM Nachrichten, die an den Bot geschickt werden in einen spezifischen Channel
     * @param channelId Die ID des Textkanals , in den DM Nachrichten an den Bot gesendet werden sollen
     */
    public enableDmLog(channelId: string): void {
        this.once('ready', () => {
            if (!this.options.intents.has('DirectMessages') || !this.options.partials?.includes(Partials.Channel) || !this.options.intents.has('MessageContent') || !this.channels.cache.get(channelId)) {
                this.error('DM Logger konnte nicht aktiviert werden, da mindestens eine der Folgenden Abhängigkeiten nicht gegeben ist:')
                this.error('Ungültige Kanal ID')
                this.error('Intent: "DirectMessages"')
                this.error('Intent: "MessageContent"')
                this.error('Partial: "Channel"')
                this.error('Stelle sicher, dass all diese Abhängigkeiten gegeben sind und versuche es erneut')
            } else {
                this.info('DM Logger aktiviert!')
                this.on('messageCreate', async message => {
                    if (message.channel.type != ChannelType.DM) return
                    const channel = this.channels.cache.get(channelId) as GuildTextBasedChannel
                    const embed = new EmbedBuilder({
                        author: { name: message.author.username, iconURL: message.author.displayAvatarURL() },
                        description: message.content,
                        color: Colors.Gold
                    })

                    await channel.send({ embeds: [embed] })
                })
            }
        })
    }
    /**
     * Aktiviert die automatische Rollenverteilung für neue Mitglieder
     * @param roles Die ID oder IDs der Rolle/n
     */
    public enableAutoRole(...roles: RoleResolvable[]) {
        if (!this.options.intents.has('GuildMembers')) {
            this.error('AutoRole konnte nicht aktiviert werden, da der Intent "GuildMembers" nicht gegeben ist!')
            return
        } else {
            this.info('AutoRole aktiviert!')
            this.once('ready', async () => {
                this.on('guildMemberAdd', async member => {
                    member.roles.add(roles)
                })
            })
        }
    }

    /**
     * Gibt eine Nachricht im Format `[{ZEIT} WARN] {message}` aus
     * @param message Die Warnung
     */
    public warn(message: string): void {
        console.log(chalk.yellowBright(`[${new Date().toLocaleTimeString('de-DE')} WARN] ${message}`))
    }
    /**
     * Gibt eine Nachricht im Format `[{ZEIT} INFO] {message}` aus
     * @param message Die Info Nachricht
     */
    public info(message: string): void {
        console.log(chalk.greenBright(`[${new Date().toLocaleTimeString('de-DE')} INFO]`), chalk.whiteBright(message))
    }
    /**
     * Gibt eine Rote nachricht im Format `[{ZEIT} ERROR] {message}` aus
     * @param message Die Error Nachricht
     * */
    public error(message: string): void {
        console.log(chalk.redBright(`[${new Date().toLocaleTimeString('de-DE')} ERROR] ${message}`))
    }
    /**Gibt eine Meldung in der Konsole, wenn der Bot bereit ist */
    public logWhenReady(): void {
        this.on('ready', () => {
            this.info(`Logged in as ${this.user!.tag}`)
        })
    }
    /**
     * Kümmert sich um alle Interactions
     * @param client Nur erforderlich, wenn eine eigene Client-Klasse verwendet wird
     * */
    public handleInteractions(client?: ExtendedClient) {
        this.on('interactionCreate', async interaction => {
            switch (true) {
                case interaction.isChatInputCommand(): {
                    const command = this.commands.get(interaction.commandName)
                    if (!command) {
                        interaction.reply({ content: 'This command could not be found!', ephemeral: true })
                        break
                    }
                    if (command.cooldown) {
                        if (this.cooldowns.isInCooldown(interaction.user.id, command.data.name)) {
                            const remainingTime = this.cooldowns.getRemainingTime(interaction.user.id, interaction.commandName)
                            const embed = new EmbedBuilder({
                                title: 'Cooldown',
                                description: `Du musst noch ${remainingTime} Minuten warten, bis du diesen Befehl erneut verwenden kannst!`,
                                color: Colors.Gold
                            })
                            interaction.reply({ embeds: [embed], ephemeral: true })
                            return
                        } else {
                            this.cooldowns.set(interaction.user.id, interaction.commandName, command.cooldown)
                        }
                    }
                    command.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isButton(): {
                    const button = this.buttons.get(interaction.customId)
                    if (!button) {
                        interaction.reply({ content: 'This button could not be found!', ephemeral: true })
                        break
                    }
                    button.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isStringSelectMenu(): {
                    const stringSelectMenu = this.stringSelectMenus.get(interaction.customId)
                    if (!stringSelectMenu) {
                        interaction.reply({ content: 'This StringSelectmenu could not be found!', ephemeral: true })
                        break
                    }
                    stringSelectMenu.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isRoleSelectMenu(): {
                    const roleSelectMenu = this.roleSelectMenus.get(interaction.customId)
                    if (!roleSelectMenu) {
                        interaction.reply({ content: 'This RoleSelectMenu could not be found!', ephemeral: true })
                        break
                    }
                    roleSelectMenu.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isChannelSelectMenu(): {
                    const channelSelectMenu = this.channelSelectMenus.get(interaction.customId)
                    if (!channelSelectMenu) {
                        interaction.reply({ content: 'This ChannelSelectMenu could not be found!', ephemeral: true })
                        break
                    }
                    channelSelectMenu.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isUserSelectMenu(): {
                    const userSelectMenu = this.userSelectMenus.get(interaction.customId)
                    if (!userSelectMenu) {
                        interaction.reply({ content: 'This UserSelectMenu could not be found!', ephemeral: true })
                        break
                    }
                    userSelectMenu.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isMentionableSelectMenu(): {
                    const mentionableSelectMenu = this.mentionableSelectMenus.get(interaction.customId)
                    if (!mentionableSelectMenu) {
                        interaction.reply({ content: 'This MenitonableSelectMenu could not be found!', ephemeral: true })
                        break
                    }
                    mentionableSelectMenu.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isModalSubmit(): {
                    const modal = this.modals.get(interaction.customId)
                    if (!modal) {
                        interaction.reply({ content: 'This Modal could not be found!', ephemeral: true })
                        break
                    }
                    modal.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isUserContextMenuCommand(): {
                    const userContextMenu = this.userContextMenus.get(interaction.commandName)
                    if (!userContextMenu) {
                        interaction.reply({ content: 'This UserContextMenu could not be found', ephemeral: true })
                        break
                    }
                    userContextMenu.execute(interaction, client ? client : this)
                    break
                }
                case interaction.isMessageContextMenuCommand(): {
                    const messageContextMenu = this.messageContextMenus.get(interaction.commandName)
                    if (!messageContextMenu) {
                        interaction.reply({ content: 'This MessageContextMenu could not be found!', ephemeral: true })
                        break
                    }
                    messageContextMenu.execute(interaction, client ? client : this)
                    break
                }
            }
        })
    }

    public deployCommands(guildIdOrIds: string | string[]): void {
        this.on('ready', () => {
            if (Array.isArray(guildIdOrIds)) {
                for (const id of guildIdOrIds) {
                    const guild = this.guilds.cache.get(id)
                    if (!guild) {
                        this.error(`${id}: Could not load Commands because of invalid GuildId`)
                        continue
                    }
                    guild.commands.set(this.apps.map(a => a.data))
                    this.info(`Deployed Commands to ${id}`)
                }
            } else {
                const guild = this.guilds.cache.get(guildIdOrIds)
                if (!guild) {
                    this.error(`${guildIdOrIds}: Could not deploy Commands because of invalid GuildId`)
                    return
                }
                guild.commands.set(this.apps.map(a => a.data))
                this.info(`Deployed Commands to ${guild.name}`)
            }

        })
    }

    public async loadCommands(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`Commands path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn('Skip Load Commands because of no Commands')
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const command = module.default as SlashCommand
            if (!command || !command.data || !command.data.name || !command.data.description) {
                this.warn(`Invalid Command in ${path}/${file}`)
                continue
            }

            this.commands.set(command.data.name, command)
            this.apps.push(command)
            this.info(`Slash Command ${command.data.name} loaded`)
        }
    }

    public async loadEvents(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`Event path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn('Skip Load Events because of no Events')
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const event = module.default as Event
            if (!event || !event.name) {
                this.warn(`Invalid Event in ${path}/${file}`)
                continue
            }

            if (event.once) {
                this.once(event.name, (...args) => event.execute(this, ...args))
            } else {
                this.on(event.name, (...args) => event.execute(this, ...args))
            }
            this.info(`"${event.name}" Event ${file.split('.')[0]} loaded`)
        }
    }

    public async loadRoleSelectMenus(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`RoleSelectMenus path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn(`Skip loading RoleSelectMenus because of no RoleSelectMenus`)
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const menu = module.default as RoleSelectMenu
            if (!menu || !menu.id) {
                this.warn(`Invalid RoleSelectMenu in ${path}/${file}`)
                return
            }
            this.roleSelectMenus.set(menu.id, menu)
            this.info(`RoleSelectMenu ${menu.id} loaded`)
        }
    }

    public async loadStringSelectMenus(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`StringSelectMenus path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn('Skip Load StringSelectMenus because of no StringSelectMenus')
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const menu = module.default as StringSelectMenu
            if (!menu || !menu.id) {
                this.warn(`Invalid StringSelectMenu in ${path}/${file}`)
                continue
            }

            this.stringSelectMenus.set(menu.id, menu)
            this.info(`StringSelectMenu ${menu.id} loaded`)
        }
    }

    public async loadChannelSelectMenus(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`ChannelSelectMenus path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn(`Skip load ChannelSelectMenus because of no ChannelSelectMenus`)
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const menu = module.default as ChannelSelectMenu
            if (!menu || !menu.id) {
                this.warn(`Invalid ChannelSelectMenu in ${path}/${file}`)
                return
            }
            this.channelSelectMenus.set(menu.id, menu)
            this.info(`ChannelSelectMenu ${menu.id} loaded`)
        }
    }

    public async loadUserSelectMenus(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`userSelectMenus path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn('Skip load UserSelectMenus because of no UserSelectMenus')
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const menu = module.default as UserSelectMenu
            if (!menu || !menu.id) {
                this.warn(`Invalid UserSelectMenu in ${path}/${file}`)
                return
            }
            this.userSelectMenus.set(menu.id, menu)
            this.info(`UserSelectMenu ${menu.id} loaded`)
        }
    }

    public async loadMentionableSelectMenus(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`MentionableSelectMenus path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn('Skip load MentionableSelectMenus because of no MentionableSelectMenus')
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const menu = module.default as MentionableSelectMenu
            if (!menu || !menu.id) {
                this.warn(`Invalid MentionableSelectMenu in ${path}/${file}`)
                return
            }
            this.mentionableSelectMenus.set(menu.id, menu)
            this.info(`MentionableSelectMenu ${menu.id} loaded`)
        }
    }

    public async loadButtons(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`Buttons path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn('Skip Load Buttons because of no Buttons')
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const button = module.default as Button
            if (!button || !button.id) {
                this.warn(`Invalid Button in ${path}/${file}`)
                continue
            }
            this.buttons.set(button.id, button)
            this.info(`Button ${button.id} loaded`)
        }
    }

    public async loadModals(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`Modals path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn('Skip Load Modals because of no Modals')
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const modal = module.default as Modal
            if (!modal || !modal.id) {
                this.warn(`Invalid Modal in ${path}/${file}`)
                continue
            }
            this.modals.set(modal.id, modal)
            this.info(`Modal ${modal.id} loaded`)
        }
    }

    public async loadUserContextMenus(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`userContextMenus path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn(`Skip load UserContextMenus because of no UserContextMenus`)
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const menu = module.default as UserContextMenu
            if (!menu.data.name) {
                this.warn(`Invalid UserContextMenu in ${path}/${file}`)
                return
            }
            this.userContextMenus.set(menu.data.name, menu)
            this.apps.push(menu)
            this.info(`UserContextMenu ${menu.data.name} loaded`)
        }
    }

    public async loadMessageContextMenus(path: string): Promise<void> {
        if (!existsSync(path)) {
            this.error(`MessageContextMenus path does not exist: ${path}`)
            return
        }
        const files = readdirSync(path).filter(f => f.endsWith('.ts'))
        if (!files || files.length == 0) {
            this.warn(`Skip load MessageContextMenus because of no MessageContextMenus`)
            return
        }
        for (const file of files) {
            const module = await import(`../../../${path}/${file}`)
            const menu = module.default as MessageContextMenu
            if (!menu.data.name) {
                this.warn(`Invalid MessageContextMenu in ${path}/${file}`)
                return
            }
            this.messageContextMenus.set(menu.data.name, menu)
            this.apps.push(menu)
            this.info(`MessageContextMenu ${menu.data.name} loaded`)
        }
    }

}

export class MemberManager {
    member: GuildMember
    guild: Guild

    constructor(member: GuildMember, guild: Guild) {
        this.member = member
        this.guild = guild
    }

    public async sendDM(options: string | MessagePayload | MessageCreateOptions): Promise<boolean> {
        await this.member.user.send(options)
            .catch(e => {
                return false
            })

        return true
    }
}